# Lab1

## 练习一

1. 借助`la sp,bootstacktop`指令，把`bootstacktop`对应的地址赋予`sp`寄存器，指令的目的是完成栈的初始化，并为栈分配相应的内存空间。
2. `tail kern_init`采用尾调用的方式，在函数`kern_init`所在位置继续执行，指令的目的是进入操作系统的入口，同时避免此次函数调用对`sp`寄存器造成影响。

## 练习二

首先我们打开终端，进入`OS1`实验根目录，并拆分成两个窗口。

在第一个终端输入以下命令启动 QEMU：该命令会让 QEMU 暂停在 CPU 加电的那一刻，同时开启 1234 端口等待 GDB 连接，为后续跟踪启动流程做准备。

```
make debug
```

切换到第二个终端，输入以下命令启动 GDB 并自动连接到 QEMU。

```
make gdb
```

GDB 成功启动并连接后，显示以下信息，表明它停在了 RISC-V 的复位地址 `0x1000`。

![GDB连接成功](https://raw.githubusercontent.com/Dou-Dou-Da-D1/OS/master/OS1/images/1.png)

这里需要注意：`0x1000` 并非随机地址，而是 QEMU 模拟的 RISC-V 处理器硬件加电后的复位地址——CPU 加电或复位时，硬件会强制将程序计数器（PC）设置为这个固定值，因此从 `0x1000` 开始执行的，就是系统启动的第一条指令。

为了进一步确认这些初始指令的功能，我们在 GDB 提示符下输入 `x/10i $pc`，查看当前 PC 指向的 10 条汇编指令，观察到如下的指令序列：

![指令序列](https://raw.githubusercontent.com/Dou-Dou-Da-D1/OS/master/OS1/images/5.png)

这些指令的核心作用是**完成最基础的硬件识别和快速跳转到完整的 OpenSBI 固件**。具体分析如下：

1. `auipc t0, 0x0` 和 `addi a1, t0, 32`：

    * 这两条指令组合起来，是 `la a1, some_label`（Load Address）伪指令的具体实现。
    * `auipc` (Add Upper Immediate to PC) 将当前 PC 值（`0x1000`）的高 20 位加载到 `t0`。
    * `addi` (Add Immediate) 将 t0 的值加上一个 12 位的立即数（这里是 32），并将结果存入 `a1`。
    * 其最终效果是计算出 MROM 代码中某个数据结构（很可能是设备树地址或其他配置信息）的物理地址，并将其存入 `a1` 寄存器，作为后续调用的参数。

2. `csrr a0`, `mhartid`：
    * 这条指令读取 `mhartid` 寄存器，获取当前正在执行的 CPU 核心的 ID。
    * 这个 ID 被存入 `a0` 寄存器。在 RISC-V 的调用约定中，`a0` 和 `a1` 通常用于传递函数参数。

3. `ld t0`, `24(t0)` 和 `jr t0`：
    * 这是整个 MROM 代码的核心跳转逻辑。
    * `ld` (Load Doubleword) 从内存中加载一个 64 位的值。它的源地址是 `t0` 寄存器的值加上 24。`t0` 在 `auipc` 指令后，其值是 `0x1000` 的高 20 位扩展，加上 24 后，指向 MROM 代码段中一个特定的位置。这个位置存储的就是完整 OpenSBI 固件的入口地址。
    * `jr t0` (Jump Register) 指令将 `t0` 寄存器中的值（即刚刚加载的 OpenSBI 入口地址）赋给程序计数器 PC，从而实现跳转。


MROM 代码执行完成后，会自动跳转到`0x80000000`（OpenSBI 固件的加载地址）。为避免手动单步跟踪大量 SBI 代码，按 tips 建议通过观察点捕捉内核加载瞬间：

1. 在 GDB 中输入`b *0x80000000`，给 OpenSBI 入口设断点，再输入`c`让程序执行，触发断点后表明已进入 SBI 固件。
    ![显示1](https://raw.githubusercontent.com/Dou-Dou-Da-D1/OS/master/OS1/images/2.png)
2. 为了观察内核被加载到 `0x80200000` 的瞬间，我在进入 OpenSBI 后，输入`watch *0x80200000`设置内存观察点。
    然而，程序并没有因为观察点被触发而中断，而是一直运行。在等待一段时间后，我手动按下 Ctrl+C 中断了程序。
    ![内存观察点](https://raw.githubusercontent.com/Dou-Dou-Da-D1/OS/master/OS1/images/6.png)

    GDB 的输出显示，程序当时已经在执行内核 `kern_init` 函数中的无限循环。这表明，**内核早已开始运行，OpenSBI 已经完成了控制权的移交**。

    为了验证这一点，我们检查 `0x80200000` 的内存内容，GDB 将该地址直接解析为 `kern_entry`，并且内存中存放的是内核的指令代码，而非零值。

这一现象说明，我的内核镜像并非由 OpenSBI 在运行时加载。相反，它是由 QEMU 通过 `-device loader` 参数在启动时预加载到 `0x80200000` 的。因此，当我在 OpenSBI 启动后设置观察点时，`0x80200000` 的内容早已是内核代码，观察点自然不会被触发。

虽然 `watch` 命令因预加载机制未达预期，但我们可以直接验证启动流程的最终阶段 —— 控制权移交。

为验证这一过程，输入`b *0x80200000`给内核入口地址设断点，再输入`c`让程序执行。

GDB 很快在`0x80200000`处中断，输入`x/1i $pc`查看指令，显示为`kern_entry`的第一条汇编指令（`auipc sp, 0x3`），证明 OpenSBI 已完成初始化，并将控制权移交内核。

![控制权](https://raw.githubusercontent.com/Dou-Dou-Da-D1/OS/master/OS1/images/7.png)

## 实验知识点与 OS 原理的对应与理解

| 实验中的知识点 | 对应的 OS 原理知识点 | 我的理解（含义、关系、差异） |
| :--- | :--- | :--- |
| **RISC-V 特权级 (M-mode, S-mode)** | **操作系统的运行模式** | **含义**：RISC-V 有多种特权级，M-mode（机器模式）拥有最高权限，负责硬件初始化和管理；S-mode（监督者模式）是操作系统内核运行的模式。<br>**关系**：实验中，OpenSBI 运行在 M-mode，完成硬件初始化后，通过环境调用（ECALL）等机制将控制权移交给运行在 S-mode 的 ucore 内核。这完美体现了 OS 原理中“底层固件为操作系统内核的运行准备环境并移交控制权”的模型。<br>**差异**：在真实的 PC 上，这个过程是由 BIOS/UEFI（运行在实模式/UEFI模式）和操作系统内核（运行在保护模式）完成的，架构和指令集不同，但思想完全一致。 |
| **中断/异常委托 (medeleg, mideleg)** | **中断和异常处理机制** | **含义**：`medeleg` 和 `mideleg` 寄存器允许 M-mode 将某些异常和中断的处理权限“委托”给 S-mode。<br>**关系**：这是 OS 原理中“操作系统内核需要直接处理用户程序产生的中断和异常（如系统调用、页错误）”这一需求的硬件实现。通过委托，内核可以在 S-mode 下直接响应这些事件，而无需每次都陷入 M-mode，提高了效率。<br>**差异**：实验中的 MROM 代码展示了如何设置这些寄存器，这比单纯的理论更具体，让我理解了机制是如何通过硬件寄存器配置来实现的。 |
| **OpenSBI 固件** | **引导加载程序 (Bootloader) 的一部分** | **含义**：OpenSBI 是 RISC-V 平台上的一个标准化的机器模式固件。<br>**关系**：它扮演了类似传统 PC 上 Bootloader（如 GRUB）的早期角色，负责初始化硬件、建立内存映射，并加载操作系统内核。它是连接底层硬件和上层操作系统的桥梁。<br>**差异**：与 GRUB 不同，OpenSBI 更底层，它本身被加载到固定地址，并且它的主要工作之一是为内核准备好一个标准的环境（SBI 调用接口），而不仅仅是加载内核。 |
| **栈初始化 (`la sp, bootstacktop`)** | **程序运行的栈环境** | **含义**：栈是程序运行不可或缺的一部分，用于存放函数调用的返回地址、参数和局部变量。<br>**关系**：从汇编语言过渡到 C 语言，必须先建立好栈。实验中的这条指令正是为即将运行的 C 语言内核代码（`kern_init`）准备了栈空间，是 OS 原理中“操作系统自身也需要运行环境”的体现。<br>**差异**：应用程序的栈由操作系统内核在创建进程时分配，而操作系统内核的栈需要由它自己在启动的最早期手动设置。 |
| **内核加载地址 (`0x80200000`)** | **链接地址与加载地址** | **含义**：`0x80200000` 是内核被链接器指定的运行地址（链接地址），也是 QEMU 加载它的地址（加载地址）。<br>**关系**：操作系统内核是一个大的程序，必须被加载到内存中才能运行。链接器脚本（`kernel.ld`）定义了它的各个段（如代码段、数据段）应该放在哪个内存地址。实验展示了这两个地址在简单情况下可以是一致的。<br>**差异**：在更复杂的场景（如内核需要从硬盘加载到低地址，再搬迁到高地址运行），加载地址和链接地址会不同，需要更复杂的启动代码来处理。 |
